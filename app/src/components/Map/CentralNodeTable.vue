<template>
	<MglCustomControl v-if="store.centerNodeSimModeData.table.show" :position="props.position"
		class="bg-white max-h-96 w-96 maplibregl-ctrl">
		<div class="grid grid-cols-7 gap-2 m-3 items-end">
			<div class="col-span-4">
				<h2 class="text-lg font-medium text-gray-900">Central Node Table</h2>
				<p class="mt-1 text-sm text-gray-600">Signal power between central node and other nodes</p>
			</div>
			<div class="col-span-3">
				<DropDown title="Sort methods" :options="sortMethods" v-model="selectedSortMethod"
					:btnOptions="{ labelColor: 'text-gray-900' }" />
			</div>
		</div>
		<div class="mt-8 px-1 flow-root">
			<div class="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
				<div class="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
					<table class="relative min-w-full divide-y divide-gray-300">
						<thead>
							<tr>
								<th scope="col" class="py-3.5 px-1 text-center text-sm font-semibold text-gray-800">
									<a href="#" class="group inline-flex" @click="sortByColumn(0)">
										TX / RX
										<span class="ml-2 flex-none rounded text-gray-400">
											<ChevronUpIcon v-if="colsSortWays.get(0) === 'desc'" class="size-5" aria-hidden="true" />
											<ChevronDownIcon v-else class="size-5" aria-hidden="true" />
										</span>
									</a>
								</th>
								<th v-for="(col, index) in colsNames" :key="index" scope="col"
									class="py-3.5 px-1 text-center text-sm font-semibold text-gray-900 sm:pl-0">
									<a href="#" class="group inline-flex" @click="sortByColumn(index + 1)">
										{{ col }}
										<span class="ml-2 flex-none rounded text-gray-400">
											<ChevronUpIcon v-if="colsSortWays.get(index + 1) === 'desc'" class="size-5" aria-hidden="true" />
											<ChevronDownIcon v-else class="size-5" aria-hidden="true" />
										</span>
									</a>
								</th>
							</tr>
						</thead>
						<tbody class="divide-y divide-gray-200 bg-white">
							<tr v-for="(row, rowIndex) in rows" :key="rowIndex">
								<td v-for="(cell, cellIndex) in row" :key="cellIndex"
									class="whitespace-nowrap text-center py-4 px-1 text-sm font-medium text-gray-900">
									{{ cell }}</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</MglCustomControl>
</template>
<script setup lang="ts">
import { MglCustomControl } from "@indoorequal/vue-maplibre-gl";
import type { ControlPosition } from "maplibre-gl";
import { ref, watch } from "vue";
import { useStore } from "../../stores/store";
import DropDown from "../Inputs/DropDown.vue";
import { ChevronDownIcon, ChevronUpIcon } from '@heroicons/vue/20/solid'

export type CentralNodetableProps = {
	position: ControlPosition | undefined;
};

const sortMethods = [
	{ id: "average", title: "Average" }
]
const selectedSortMethod = ref(sortMethods[0].id);

const props = defineProps<CentralNodetableProps>();

const store = useStore();

const cols = ref<string[]>([]);
const colsNames = ref<string[]>([]);
const rows = ref<string[][]>([]);
const colsSortWays = ref<Map<number, 'asc' | 'desc'>>(new Map());

watch(
	() => store.centerNodeSimModeData.table.data,
	(newData) => {
		if (newData.length > 0) {
			// Extract unique rx_ids once
			cols.value = Array.from(new Set(newData.map((val) => val.rx_id)));

			// Map column IDs to titles
			colsNames.value = cols.value.map((colId) => {
				const node = newData.find((val) => val.rx_id === colId);
				return node ? node.rx_title : colId;
			});

			// create array of tx_ids
			const txIds = Array.from(new Set(newData.map((val) => val.tx_id)));

			// Create rows based on tx_ids
			rows.value = txIds.map((txId) => {
				const row = [
					`${newData.find((val) => val.tx_id === txId)?.tx_title || txId}`,
				];
				for (const colId of cols.value) {
					const value = newData.find(
						(val) => val.tx_id === txId && val.rx_id === colId,
					);
					row.push(value ? `${value.rx_signal_power} dBm` : "N/A");
				}
				return row;
			});
		} else {
			cols.value = [];
			colsNames.value = [];
			rows.value = [];
		}
	},
	{ immediate: true, deep: true },
);

function sortByColumn(columnIndex: number) {
	const isRSSI = columnIndex > 0;

	// 1) decide next direction first (outside comparator)
	const current = colsSortWays.value.get(columnIndex) ?? 'desc';
	const next = current === 'asc' ? 'desc' : 'asc';
	colsSortWays.value.set(columnIndex, next);
	const dir = next === 'asc' ? 1 : -1;

	const compare = (a: string, b: string): number => {
		let an = 0;
		let bn = 0;

		if (isRSSI) {
			an = parseFloat(a.split(" ")[0]);
			bn = parseFloat(b.split(" ")[0]);
		} else {
			an = parseFloat(a.split(" ")[1]);
			bn = parseFloat(b.split(" ")[1]);
		}

		if (!isNaN(an) && !isNaN(bn)) {
			return an - bn;
		}
		// fallback: natural string compare
		return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
	};

	// 3) sort (clone to ensure Vue reactivity if needed)
	rows.value = [...rows.value].sort((r1, r2) => compare(r1[columnIndex], r2[columnIndex]) * dir);
}

</script>